# TypeScript 泛型

> Generics

泛型是指类型在定义时不明确指明而是预先占位，等使用时再根据传入的泛型参数决定具体的类型

TypeScript 的 [内置工具类型](./utility-types.md) 也多为泛型

::: code-group

```ts [泛型类型别名]
type 类型别名<泛型参数1, 泛型参数2> = ...;
```

```ts [泛型接口]
interface 接口<泛型参数1, 泛型参数2> {
  // ...
}
```

```ts [泛型函数]
// 一般函数
function 函数<泛型参数1, 泛型参数2>() {
  // ...
}

// 箭头函数
const 函数 = <泛型参数1, 泛型参数2>() => {
  // ...
};

// 箭头函数 + 类型别名
type 类型别名<泛型参数1, 泛型参数2> = () => 返回值类型;
const 函数: 类型别名<泛型参数1, 泛型参数2> = () => {
  // ...
};

函数<泛型参数>();
函数<泛型参数1, 泛型参数2>();
```

:::

### 泛型参数的默认值

可以将某个类型指定为泛型参数的默认值

当泛型参数有默认值时，在使用时对应位置可以不传入泛型参数

::: code-group

```ts [泛型类型别名]
type 类型别名<泛型参数 = 默认类型> = ...;
```

```ts [泛型接口]
interface 接口<泛型参数 = 默认类型> {
  // ...
}
```

```ts [泛型函数]
// 一般函数
function 函数<泛型参数1, 泛型参数2 = 默认类型>() { ... };

// 箭头函数
const 函数 = <泛型参数1, 泛型参数2 = 默认类型>() => { ... };


函数<泛型参数1, 泛型参数2>();
函数<泛型参数1>();
```

:::

## 泛型参数的约束

> Generic Type Constraints

泛型参数的约束是指限制泛型泛型参数可以接受的泛型参数的范围，从而提升类型的安全性

::: code-group

```ts [泛型类型别名]
type 类型别名<泛型参数 extends 类型> = ...;
```

```ts [泛型接口]
interface 接口<泛型参数 extends 类型> {
  // ...
}
```

```ts [泛型函数]
// 一般函数
function 函数<泛型参数 extends 类型>() {
  // ...
}

// 箭头函数
const 函数 = <泛型参数 extends 类型>() => {
  // ...
};
```

:::

::: details 例子：通过泛型约束限定函数参数必须是含有规定键值对的对象

```ts
function func<T extends { name: string }>(params: T) {
  // ...
}

func(10); // [!code error]
func({}); // [!code error]
func({ name: "Andy" });
func({ name: "Andy", age: 28 });
```
